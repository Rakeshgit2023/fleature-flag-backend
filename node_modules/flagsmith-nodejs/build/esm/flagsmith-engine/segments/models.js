import * as semver from 'semver';
import { getCastingFunction as getCastingFunction } from '../utils/index.js';
import { ALL_RULE, ANY_RULE, NONE_RULE, NOT_CONTAINS, REGEX, MODULO, IN, CONDITION_OPERATORS } from './constants.js';
import { isSemver } from './util.js';
export const all = (iterable) => iterable.filter(e => !!e).length === iterable.length;
export const any = (iterable) => iterable.filter(e => !!e).length > 0;
export const matchingFunctions = {
    [CONDITION_OPERATORS.EQUAL]: (thisValue, otherValue) => thisValue == otherValue,
    [CONDITION_OPERATORS.GREATER_THAN]: (thisValue, otherValue) => otherValue > thisValue,
    [CONDITION_OPERATORS.GREATER_THAN_INCLUSIVE]: (thisValue, otherValue) => otherValue >= thisValue,
    [CONDITION_OPERATORS.LESS_THAN]: (thisValue, otherValue) => thisValue > otherValue,
    [CONDITION_OPERATORS.LESS_THAN_INCLUSIVE]: (thisValue, otherValue) => thisValue >= otherValue,
    [CONDITION_OPERATORS.NOT_EQUAL]: (thisValue, otherValue) => thisValue != otherValue,
    [CONDITION_OPERATORS.CONTAINS]: (thisValue, otherValue) => !!otherValue && otherValue.includes(thisValue)
};
export const semverMatchingFunction = {
    ...matchingFunctions,
    [CONDITION_OPERATORS.EQUAL]: (thisValue, otherValue) => semver.eq(thisValue, otherValue),
    [CONDITION_OPERATORS.GREATER_THAN]: (thisValue, otherValue) => semver.gt(otherValue, thisValue),
    [CONDITION_OPERATORS.GREATER_THAN_INCLUSIVE]: (thisValue, otherValue) => semver.gte(otherValue, thisValue),
    [CONDITION_OPERATORS.LESS_THAN]: (thisValue, otherValue) => semver.gt(thisValue, otherValue),
    [CONDITION_OPERATORS.LESS_THAN_INCLUSIVE]: (thisValue, otherValue) => semver.gte(thisValue, otherValue)
};
export const getMatchingFunctions = (semver) => semver ? semverMatchingFunction : matchingFunctions;
export class SegmentConditionModel {
    EXCEPTION_OPERATOR_METHODS = {
        [NOT_CONTAINS]: 'evaluateNotContains',
        [REGEX]: 'evaluateRegex',
        [MODULO]: 'evaluateModulo',
        [IN]: 'evaluateIn'
    };
    operator;
    value;
    property_;
    constructor(operator, value, property) {
        this.operator = operator;
        this.value = value;
        this.property_ = property;
    }
    matchesTraitValue(traitValue) {
        const evaluators = {
            evaluateNotContains: (traitValue) => {
                return (typeof traitValue == 'string' &&
                    !!this.value &&
                    !traitValue.includes(this.value?.toString()));
            },
            evaluateRegex: (traitValue) => {
                return !!this.value && !!traitValue?.toString().match(new RegExp(this.value));
            },
            evaluateModulo: (traitValue) => {
                if (isNaN(parseFloat(traitValue)) || !this.value) {
                    return false;
                }
                const parts = this.value.split('|');
                const [divisor, reminder] = [parseFloat(parts[0]), parseFloat(parts[1])];
                return traitValue % divisor === reminder;
            },
            evaluateIn: (traitValue) => {
                return this.value?.split(',').includes(traitValue.toString());
            }
        };
        // TODO: move this logic to the evaluator module
        if (this.EXCEPTION_OPERATOR_METHODS[this.operator]) {
            const evaluatorFunction = evaluators[this.EXCEPTION_OPERATOR_METHODS[this.operator]];
            return evaluatorFunction(traitValue);
        }
        const defaultFunction = (x, y) => false;
        const matchingFunctionSet = getMatchingFunctions(isSemver(this.value));
        const matchingFunction = matchingFunctionSet[this.operator] || defaultFunction;
        const traitType = isSemver(this.value) ? 'semver' : typeof traitValue;
        const castToTypeOfTraitValue = getCastingFunction(traitType);
        return matchingFunction(castToTypeOfTraitValue(this.value), traitValue);
    }
}
export class SegmentRuleModel {
    type;
    rules = [];
    conditions = [];
    constructor(type) {
        this.type = type;
    }
    static none(iterable) {
        return iterable.filter(e => !!e).length === 0;
    }
    matchingFunction() {
        return {
            [ANY_RULE]: any,
            [ALL_RULE]: all,
            [NONE_RULE]: SegmentRuleModel.none
        }[this.type];
    }
}
export class SegmentModel {
    id;
    name;
    rules = [];
    featureStates = [];
    constructor(id, name) {
        this.id = id;
        this.name = name;
    }
}
