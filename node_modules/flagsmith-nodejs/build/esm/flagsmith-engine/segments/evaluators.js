import { getHashedPercentateForObjIds } from '../utils/hashing/index.js';
import { PERCENTAGE_SPLIT, IS_SET, IS_NOT_SET } from './constants.js';
export function getIdentitySegments(environment, identity, overrideTraits) {
    return environment.project.segments.filter(segment => evaluateIdentityInSegment(identity, segment, overrideTraits));
}
export function evaluateIdentityInSegment(identity, segment, overrideTraits) {
    return (segment.rules.length > 0 &&
        segment.rules.filter(rule => traitsMatchSegmentRule(overrideTraits || identity.identityTraits, rule, segment.id, identity.djangoID || identity.compositeKey)).length === segment.rules.length);
}
function traitsMatchSegmentRule(identityTraits, rule, segmentId, identityId) {
    const matchesConditions = rule.conditions.length > 0
        ? rule.matchingFunction()(rule.conditions.map(condition => traitsMatchSegmentCondition(identityTraits, condition, segmentId, identityId)))
        : true;
    return (matchesConditions &&
        rule.rules.filter(rule => traitsMatchSegmentRule(identityTraits, rule, segmentId, identityId)).length === rule.rules.length);
}
export function traitsMatchSegmentCondition(identityTraits, condition, segmentId, identityId) {
    if (condition.operator == PERCENTAGE_SPLIT) {
        var hashedPercentage = getHashedPercentateForObjIds([segmentId, identityId]);
        return hashedPercentage <= parseFloat(String(condition.value));
    }
    const traits = identityTraits.filter(t => t.traitKey === condition.property_);
    const trait = traits.length > 0 ? traits[0] : undefined;
    if (condition.operator === IS_SET) {
        return !!trait;
    }
    else if (condition.operator === IS_NOT_SET) {
        return trait == undefined;
    }
    return trait ? condition.matchesTraitValue(trait.traitValue) : false;
}
