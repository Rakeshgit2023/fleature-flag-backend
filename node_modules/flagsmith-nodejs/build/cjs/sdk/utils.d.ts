import { Fetch, FlagsmithTraitValue, TraitConfig } from './types.js';
import { Dispatcher } from 'undici-types';
type Traits = {
    [key: string]: TraitConfig | FlagsmithTraitValue;
};
export declare function isTraitConfig(traitValue: TraitConfig | FlagsmithTraitValue): traitValue is TraitConfig;
export declare function generateIdentitiesData(identifier: string, traits: Traits, transient: boolean): {
    identifier: string;
    traits: ({
        trait_key: string;
        trait_value: string | number | boolean | null;
        transient: boolean | undefined;
    } | {
        trait_key: string;
        trait_value: string | number | boolean | null;
        transient?: undefined;
    })[];
    transient: boolean;
} | {
    identifier: string;
    traits: ({
        trait_key: string;
        trait_value: string | number | boolean | null;
        transient: boolean | undefined;
    } | {
        trait_key: string;
        trait_value: string | number | boolean | null;
        transient?: undefined;
    })[];
    transient?: undefined;
};
export declare const delay: (ms: number) => Promise<unknown>;
export declare const retryFetch: (url: string, fetchOptions: RequestInit & {
    dispatcher?: Dispatcher;
}, retries: number | undefined, timeoutMs: number | undefined, retryDelayMs: number | undefined, customFetch: Fetch) => Promise<Response>;
/**
 * A deferred promise can be resolved or rejected outside its creation scope.
 *
 * @template T The type of the value that the deferred promise will resolve to.
 *
 * @example
 * const deferred = new Deferred<string>()
 *
 * // Pass the promise somewhere
 * performAsyncOperation(deferred.promise)
 *
 * // Resolve it when ready from anywhere
 * deferred.resolve("Operation completed")
 * deferred.failed("Error")
 */
export declare class Deferred<T> {
    readonly promise: Promise<T>;
    private resolvePromise;
    private rejectPromise;
    constructor(initial?: T);
    resolve(value: T | PromiseLike<T>): void;
    reject(reason?: unknown): void;
}
export {};
